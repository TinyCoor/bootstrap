//
// fibonacci recursive function
//

// N.B. this is how we define 'external' function prototypes
#foreign print := proc(format:string, values:...any) @alias "printf";

alpha::compiler::config := ns {
    fibonacci := ns {
        constant length_of_sequence:u32 := 1000;
    };
};

alpha::compiler::examples := ns {
    magick_number:u16 := 42;

    fuznucker := proc(/* before*/ a:u8 /*after*/, b:u8, c:u8, d:u8):/*baz */ u16 /* foo */, string {
        return /*expr before */ (a * b) + (c * d) /* expr after */, "hello world" /* string after */;
    };

    /*prod*/ product /*prod_after*/, /*msg */ msg /*msg_after*/ := fuznucker(8, 8);

    fib := proc(n:u64 := 10):u64 {
        if n == 0 || n == 1 {
            return n;
        } else {
            value := fib((n - 1) + fib(n - 2));
            print(value);
            return value;
        };
    };

    main := proc():u32 {
        final_fib_value := cast<u32>(fib(alpha::compiler::config::fibonacci::length_of_sequence));
        return final_fib_value;
    } @entry_point;
};
